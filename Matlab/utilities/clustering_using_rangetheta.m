function cluster_ids = clustering_using_rangetheta(p,range,theta)
    % Here, a scanline point cloud is separated into clusters based on
    % differences in range and angluar values (theta) of the points.
    % If at any point index the range/theta difference is greater than 
    % threshold a new cluster is generated by splitting current cluster 
    % at current index. If any of the splitting indices are similar between
    % the set of splitting indexes generated in range & theta based 
    % clustering, it is made sure that the redundancy is identified &
    % removed.

    num_pnt = numel(range);
    diff_range = range(2:end) - range(1:end-1);
    diff_theta = theta(2:end) - theta(1:end-1);

    range_threshold = p.range_threshold;
    theta_threshold = p.theta_threshold;
    
    % do threshold check
    flag_r = abs(diff_range) >= range_threshold;
    flag_t = abs(diff_theta) >= theta_threshold;
    
    index_fl_range = find(flag_r); % index of flags in range values
    index_fl_theta = find(flag_t); % index of flags in theta values
    
    % check & remove any theta based flag if its index matches with range 
    % based flag to avoid cluster breaking at same index during theta
    % difference based clustering.
    [~,i_flag_range,i_fl_theta] = intersect(index_fl_range,index_fl_theta);
    index_fl_theta(i_fl_theta) = [];
    
    [~,dim_max] = max(size(range)); % get dimension number along length of the array
    index_all = cat(dim_max,index_fl_range,index_fl_theta);
    index_all = sort(index_all,'ascend');

    num_cluster_range = sum(flag_t); % number of clusters based on range difference
    num_cluster_theta = sum(flag_t); % number of clusters based on theta difference
    
    num_cluster = numel(index_all)+1;   % +1 because dividing an array using
                                        % n breaking index results in n+1
                                        % children arrays.

    % Cluster point separation based on breaking indices
    for cluster_id = 1:num_cluster
        if cluster_id == 1
            start_idx = 1;
        else
            start_idx = index_all(cluster_id-1)+1;
        end
        if cluster_id == num_cluster
            end_idx = num_pnt;
        else
            end_idx   = index_all(cluster_id);
        end
        cluster_ids(start_idx:end_idx) = cluster_id;
    
        % If initial and final clusters are nearby each other and fall
        % within range & theta threshold, fuse them.
        if cluster_id == num_cluster
            range_check = (range(num_pnt) - range(1)) < range_threshold;
            theta_check = (theta(num_pnt) - 2*pi - theta(1)) < theta_threshold;
            if range_check && theta_check
                cluster_ids(start_idx:end_idx) = 1;
            end
        end
    end
    
end

